# -*- coding: utf-8 -*-
"""TimeSeries_Gold_Price.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SgFB2r3DKIzwnybmFJ4WcBxGFNNxv9xw

***Nama : Laily Khoirunnisa'***

*Membuat Model Prediksi Time Series 'Gold Price' (Harga Emas dari Tahun ke Tahun)*

`Submission 2-Time Series Kelas Dicoding: Pengembangan Machine Learning`

<h1> <strong> 1. Import library yang diperlukan</strong></h1>
"""

import numpy as np
import pandas as pd
import zipfile,os
from keras.layers import Dense, LSTM
import matplotlib.pyplot as plt
import tensorflow as tf
from google.colab import files
from sklearn.preprocessing import StandardScaler

"""<h1> <strong> 2. Mengambil dataset dari Kaggle</strong></h1>"""

!pip install -q kaggle
files.upload()

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!ls ~/.kaggle
!chmod 600 /root/.kaggle/kaggle.json

!kaggle datasets download -d arashnic/learn-time-series-forecasting-from-gold-price

!ls

"""<h1> <strong> 3. Ekstraksi dataset Gold Price</strong></h1>"""

local_zip = 'learn-time-series-forecasting-from-gold-price.zip'
zip_ref = zipfile.ZipFile(local_zip, 'r')
zip_ref.extractall('/tmp')
zip_ref.close()

"""<h1> <strong> 4. Preprocessing dataset Gold Price</strong></h1>

<h6> <strong> a. Mengubah dataset ke bentuk dataframe</strong></h6>
"""

df = pd.read_csv('/tmp/gold_price_data.csv')
df.head()

df.tail()

"""<h6> <strong> b. Mengubah tipe data 'Date' dari String menjadi Datetime</strong></h6>"""

df['Date']=pd.to_datetime(df['Date'], format='%Y-%m-%d')

"""<h6> <strong> c. Cek nilai Null pada data</strong></h6>"""

df.isnull().sum()

"""<h6> <strong> d. Standarisasi data dengan StandardScaler agar nilai yang diolah tidak terlalu besar namun tetap robust</strong></h6>"""

scaler = StandardScaler()
scaler = scaler.fit(df[['Value']])
df['Value'] = scaler.transform(df[['Value']])

"""<h6> <strong> e. Melihat bentuk data setelah distandarisasi</strong></h6>"""

df.describe().transpose()

"""<h1> <strong> 5. Grafik Gold Price</strong></h1>"""

date_data = df['Date'].values
price_data = df['Value'].values

plt.style.use('seaborn')
plt.figure(figsize=(15, 6))
plt.plot(date_data,price_data,color= 'darkcyan')
plt.xlabel("Year"); 
plt.ylabel("Price (US $ per ounce)");
plt.title('Gold Price',
          fontsize=20);
plt.show()

"""<h1> <strong> 6. Membagi dataset menjadi 80% data train dan 20% data test</strong></h1>"""

from sklearn.model_selection import train_test_split
price_train, price_test, date_train, date_test = train_test_split(price_data, date_data, test_size=0.2, random_state=0,shuffle=False)

len(date_train)

"""<h1> <strong> 7. Definisi fungsi <code>windowed_dataset</code> untuk mengelompokkan data time series</strong></h1>"""

def windowed_dataset(series, window_size, batch_size, shuffle_buffer):
    series = tf.expand_dims(series, axis=-1)
    ds = tf.data.Dataset.from_tensor_slices(series)
    ds = ds.window(window_size + 1, shift=1, drop_remainder=True)
    ds = ds.flat_map(lambda w: w.batch(window_size + 1))
    ds = ds.shuffle(shuffle_buffer)
    ds = ds.map(lambda w: (w[:-1], w[-1:]))
    return ds.batch(batch_size).prefetch(1)

"""<h1> <strong> 8. Mengelompokkan data dan membuat model Sequensial</strong></h1>"""

train_set = windowed_dataset(price_train, window_size=60, batch_size=100, shuffle_buffer=100)
val_set = windowed_dataset(price_test, window_size=60, batch_size=100, shuffle_buffer=100)

model = tf.keras.models.Sequential([
  tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(128, return_sequences=True)),
  tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(64, return_sequences=True)),
  tf.keras.layers.LSTM(64),
  tf.keras.layers.Dropout(0.2),
  tf.keras.layers.Dense(10, activation="relu"),
  tf.keras.layers.Dense(1),
])

"""<h1> <strong> 9. Mendefinisikan <code>Callbacks</code>: <code>EarlyStopping</code> dan <code>ModelCheckPoint</code></strong></h1>"""

#EarlyStopping and ModelCheckpoint

from keras.callbacks import EarlyStopping, ModelCheckpoint

es = EarlyStopping(monitor = 'val_mae', mode = 'min', verbose = 1, patience = 20)
mc = ModelCheckpoint('./model.h5', monitor = 'val_mae', mode = 'min', verbose = 1, save_best_only = True)

"""<h1> <strong> 10. Proses training model</strong></h1>
<h6>

```
Target MAE <10%  atau <0.4285378
```

</h6>
"""

optimizer = tf.keras.optimizers.SGD(learning_rate=1.0000e-03, momentum=0.9)
model.compile(loss=tf.keras.losses.Huber(),
              optimizer=optimizer,
              metrics=["mae"])
history = model.fit(train_set,
                    epochs=100,
                    validation_data = val_set,
                    verbose =2,
                    callbacks=[es,mc])

"""<h1> <strong> 11. Grafik Loss dan MAE dari data Training dan Test</strong></h1>"""

train_loss = history.history['loss']
train_mae = history.history['mae']

val_loss = history.history['val_loss']
val_mae = history.history['val_mae']

epochs_range = range(20)

plt.figure(figsize=(32, 6))
plt.subplot(1, 2,1)
plt.plot(train_mae, label='Training MAE')
plt.plot(val_mae, label='Validation MAE')
plt.legend(loc='upper right')
plt.title('Training and Validation MAE')

plt.subplot(1, 2,2)
plt.plot(train_loss, label='Training Loss')
plt.plot(val_loss, label='Validation Loss')
plt.legend(loc='upper right')
plt.title('Training and Validation Loss')
plt.show()

"""<h1> <strong> 12. Grafik Harga Emas(Price) Test/Validation VS Prediksi Model yang telah dibuat </strong></h1>"""

def model_forecast(model, series, window_size):
 ds = tf.data.Dataset.from_tensor_slices(series)
 ds = ds.window(window_size, shift=1, drop_remainder=True)
 ds = ds.flat_map(lambda w: w.batch(window_size))
 ds = ds.batch(32).prefetch(1)
 forecast = model.predict(ds)
 return forecast

def plot_series(time, series, format="-", start=0, end=None):
    plt.plot(time[start:end], series[start:end], format)
    plt.xlabel("Time")
    plt.ylabel("Value")
    plt.grid(True)

window_size=60

rnn_forecast = model_forecast(model, price_data[..., np.newaxis], window_size)
rnn_forecast = rnn_forecast[len(price_train)-window_size:-1, 0]
plt.figure(figsize=(10, 6))
plot_series(date_test, price_test)
plot_series(date_test, rnn_forecast)